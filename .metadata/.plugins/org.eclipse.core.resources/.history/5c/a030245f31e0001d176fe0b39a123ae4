package edu.kh.comm.member.controller;


import javax.servlet.http.HttpServletRequest;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

// extends를 사용하면 pojo를 위배하는것
//POJO 기반 프레임워크: 외부 라이브러리를 상속하면 안된다.
// 그렇기때문에 extends를 사용할 수 없다.

//*****************************************************
//class: 객체를 만들기 위한 설계도 
//-> 객체 생성 new 연산자 사용해서 클래스명 써서 불러옴(기존)
//-> 객체로 생성 되어야지 기능 수행이 가능함 new 클래스명()
//--> IOC(제어의 역전, 객체 생명주기를 스프링이 관리) 그렇기 때문에 객체 생성할 수 없음
//** 이때, 스프링이 생성한 객체 == bean 이라고 한다.
//*****************************************************

//bean 등록 == 스프링이 객체로 만들어서 가지고 있어라.
//1. 어노테이션(@Component -> @Controller) 
// 스프링이 memberController를 객체화 하여 갖고있음
//@Component // 해당 클래스를 bean으로 등록하라고 프로그램에게 알려주는 주석(annotation)

//역할: 서블릿으로 컨트롤러 하기 위해 만들어짐
//그래서 @Controller로 어노테이션 함
@Controller//생성된 bean이 Controller임을 명시 + bean 등록 

//2.RequestMapping("/url")
//->해당 url은 클라이언트가 요청함
@RequestMapping("/member") //localhost:8080/comm/member 이하의 모든 요청을 처리하는 컨트롤러 
//-> handler Mapping 부분
//원래는 로그인, signUp 등 모든 서블릿을 만들어줬엇지만 Requestmapping을 사용하여 모든 요청을
//한개로 컨트롤 할 수 있다. 
public class MemberController {
	
	//4.로거 만들기
	private Logger logger = LoggerFactory.getLogger(MemberController.class);
	//-------------------------------------------------
	
	//Controller : 요청/ 응답을 제어하는 역할을 지닌 클래스 
	/*@RequstMapping : 클리언트 요청(url)에 맞는 클래스 or 메서드를 연결시켜주는 어노테이션
	 *
	 *[위치에 따른 해석]
	 *- 클래스 레벨(클래스 위에 적은 RequestMapping 어노테이션) : 공통주소를 작성
	 *- 메서드 레벨(메서드 위에 적는 것) : 공통주소 외 나머지 하위 주소를 작성
	 * 
	 * 단, 클래스 레벨에 @RequestMapping이 존재하지 않는다면
	 * - 메서드 레벨은 단독 요청 처리 주소이다. 
	 * 만약에, 위에 클래스에 해당 어노테이션이 없는데 메서드에만 어노테이션이 되어있으면
	 * //localhost:8080/comm/login 이렇게 진행되기 때문에 member/login과 다르다.
	 *-> login 메서드에 단독으로 요청을 보냄
	 * 
	 * [작성법에 따른 해석]
	 * 1) @RequestMapping("url")
	 * --> 요청 방식(get/post) get,post 관계 없이 url이 일치하는 요청을 처리한다.
	 * 
	 * 2) @RequestMapping(value = "url", method=RequestMethod.GET | POST)
	 * --> get으로 원하면 get으로 post로 적혀있으면 post로 요청 처리
	 *	== 요청 방식에 따라 요청을 처리한다. 
	 * 
	 */
	
//	//3. 파라미터 얻어오기 1번
//	
//	//로그인
//	// 요청시 파라미터를 얻어오는 방법 1
//	// -> HttpServletRequest를 이용하여 얻어올 수 있다. 
//	
//	//login 메서드
//	//localhost:8080/comm/member/login
//	//login에 들어오는 요청은 아래로 들어온다!
//	@RequestMapping("/login")
//	public String login(HttpServletRequest req) {
//		
//		//5. 로거 실행되는지 확인
//		logger.info("로그인 요청됨");
//		
//		//--- 4해당 부분 
//		String inputEmail = req.getParameter("inputEmail");
//		String inputPw = req.getParameter("inputPw");
//		
//		//---5해당 부분
//		logger.debug("inputPw:: " + inputPw);
//		logger.debug("inputEmail:: " + inputEmail);
//		/* 로그인창에 아이디 비번을 치면 
//		 * 2023-04-21 19:25:43 [INFO] 로그인 요청됨
//		 * 2023-04-21 19:25:43 [DEBUG] inputPw:: pass03#
//			2023-04-21 19:25:43 [DEBUG] inputEmail:: user03@kh.or.kr
//			콘솔창에 뜬다
//		 */
//		
//		
//		return "redirect:/";
//	
//	
//	
//	}
	
	// 3. 요청시 파라미터 얻어오는 방법 2 
	//-> @RequestParam 어노테이션 사용 
	

	//작성방법 : @RequestParam("name 속성값") 자료형 변수명
	//- 클라이언트 요청 시 같이 전달 된 파라미터를 변수에 저장
	// --> 어떤 파라미터를 변수에 저장할지는 "name 속성값"을 이용해 지정한다. 
	
//	@RequestMapping("/login")
//	public String login(@RequestParam("inputEmail") String email,
//						@RequestParam("inputPw") String pw) {
//		logger.info("로그인 요청됨");
//		
//		logger.debug("email : " + email);
//		logger.debug("pw : " + pw);
//		
//		return "redirect:/";
//	}
	
	// 더 줄이기 
	// @RequestParam을 생략하지만 파라미터를 얻어오는 방법!
	// -> name 속성갑소가 파라미터를 저장할 변수 이름을 동일하게 작성
	
	@RequestMapping("/login")
	public String login(String inputEmail, String inputPw) {
		logger.info("로그인 요청됨");
		
		logger.debug("email : " + inputEmail);
		logger.debug("pw : " + inputPw);
		
		return "redirect:/";
	}


}
